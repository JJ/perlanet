#!/usr/bin/env perl

use strict;
use warnings;

use open ':utf8';
use Encode;
use Encode::Detect;
use List::Util 'min';
use LWP::Simple;
use XML::Feed;
use Template;
use DateTime;
use DateTime::Duration;
use YAML 'LoadFile';
use HTML::Tidy;
use HTML::Scrubber;

require XML::OPML::SimpleGen;

use vars qw{$VERSION};
BEGIN {
  $VERSION = '0.01';
}

=head1 NAME

Perlanet - A program for creating web pages that aggregate web feeds (both RSS and Atom).

=head1 SYNOPSIS

Perlanet is a program for creating web pages that aggregate web feeds (both RSS and Atom). Web pages like this are often called "Planets" after the Python software which originally popularised them. Perlanet is a planet builder written in Perl - hence "Perlanet".

The emphasis on Perlanet is firmly on simplicity. It reads web feeds, merges them and publishes the merged feed as a web page and as a new feed. That's all it is intended to do. If you want to do more with your feeds (create feeds from inputs that don't publish feeds, filter or transform them in complex ways or publish them in interesting ways) then Perlanet isn't the right software for you. In that case I recommend that you take a look at Plagger - which is another feed aggregator, but one that is far more complex and, therefore, far more flexible.

=cut

my $cfg_file = shift || './perlanetrc';

my $cfg = LoadFile($cfg_file);

my @entries;

my $opml;
if ($cfg->{opml}) {
  $opml = XML::OPML::SimpleGen->new;
  $opml->head(
    title => $cfg->{title},
  );
}

foreach my $f (@{$cfg->{feeds}}) {
  my $data = get($f->{url});
  my $feed = eval { XML::Feed->parse(\$data) };

  if ($@) {
    warn "$f->{url}\n$@\n";
    next;
  }

  unless ($feed) {
    warn "$f->{url}\nNo feed\n";
    next;
  }

  $feed = $feed->convert($cfg->{feed}{format});

  unless (defined $f->{title}) {
    $f->{title} = $feed->title;
  }

  push @entries, map { $_->title($f->{title} . ': ' . $_->title); $_ }
                       $feed->entries;

  if ($cfg->{opml}) {
    $opml->insert_outline(
      text    => $f->{title},
      xmlUrl  => $f->{url},
      htmlUrl => $f->{web},
    );
  }
}

if ($cfg->{opml}) {
  $opml->save($cfg->{opml});
}

my $entries = min(scalar @entries, $cfg->{entries});

my $day_zero = DateTime->from_epoch(epoch=>0);

@entries = sort {
                  ($b->issued || $b->modified || $day_zero)
                   <=>
                  ($a->issued || $b->modified || $day_zero)
                } @entries;

my $week_in_future = DateTime->now + DateTime::Duration->new(weeks => 1);
@entries =
  grep { ($_->issued || $_->modified || $day_zero) < $week_in_future }
  @entries;

# Preferences for HTML::Tidy
my %tidy = (
  doctype      => 'omit',
  output_xhtml => 1,
  wrap         => 0,
  alt_text     => '',
  break_before_br => 0,
  input_encoding => 'utf8',
  output_encoding => 'utf8',
  tidy_mark => 0,
  show_body_only => 1,
);

# Rules for HTML::Scrub
my %scrub_rules = (
  img    => {
    src   => qr{^http://},    # only URL with http://
    alt   => 1,               # alt attributes allowed
    align => 1,               # allow align on images
    style => 1,
    '*'   => 0,               # deny all others
  },
  style  => 0,
  script => 0,
  span   => {
    id    => 0,               # blogger(?) includes spans with id attribute
  },
);

# Definitions for HTML::Scrub
my %scrub_def = (
  '*'           => 1,
  'href'        => qr{^(?!(?:java)?script)}i,
  'src'         => qr{^(?!(?:java)?script)}i,
  'cite'        => '(?i-xsm:^(?!(?:java)?script))',
  'language'    => 0,
  'name'        => 1,
  'value'       => 1,
  'onblur'      => 0,
  'onchange'    => 0,
  'onclick'     => 0,
  'ondblclick'  => 0,
  'onerror'     => 0,
  'onfocus'     => 0,
  'onkeydown'   => 0,
  'onkeypress'  => 0,
  'onkeyup'     => 0,
  'onload'      => 0,
  'onmousedown' => 0,
  'onmousemove' => 0,
  'onmouseout'  => 0,
  'onmouseover' => 0,
  'onmouseup'   => 0,
  'onreset'     => 0,
  'onselect'    => 0,
  'onsubmit'    => 0,
  'onunload'    => 0,
  'src'         => 1,
  'type'        => 1,
  'style'       => 1,
);

my $tidy = HTML::Tidy->new(\%tidy);
$tidy->ignore( type => TIDY_WARNING );

my $scrub = HTML::Scrubber->new;
$scrub->rules(%scrub_rules);
$scrub->default(1, \%scrub_def);

my $f = XML::Feed->new($cfg->{feed}{format});
$f->title($cfg->{title});
$f->link($cfg->{url});
$f->description($cfg->{description});
$f->author($cfg->{author}{name});
if ($cfg->{feed}{format} eq 'Atom') {
  my $p = $f->{atom}->author;
  $p->email($cfg->{author}{email});
}
$f->modified(DateTime->now);
foreach (1 .. $entries) {
  my $entry = $entries[$_ - 1];
  if ($entry->content->type && $entry->content->type eq 'text/html') {
    my $scrubbed = $scrub->scrub($entry->content->body);
    my $clean = $tidy->clean($scrubbed);

    # hack to remove a particularly nasty piece of blogspot HTML
    $clean =~ s|<div align="justify"></div>||g;
    $entry->content($clean);
  }

  $f->add_entry($entry);
}

open my $feedfile, '>', $cfg->{feed}{file} or die $!;
print $feedfile $f->as_xml;
close $feedfile;

my $tt = Template->new;

$tt->process($cfg->{page}{template},
             { feed => $f, cfg => $cfg },
             $cfg->{page}{file},
             { binmode => ':utf8' })
  or die $tt->error;


=head1 TO DO

See http://trac.mag-sol.com/perlanet/wiki

=head1 AUTHOR

Dave Cross, <dave@mag-sol.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008 by Magnum Solutions Ltd.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.0 or,
at your option, any later version of Perl 5 you may have available.

=cut
