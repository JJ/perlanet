#!/usr/bin/perl

use strict;
use warnings;

use List::Util;
use URI;
use XML::Feed;
use Template;
use DateTime;
use YAML 'LoadFile';
use HTML::Tidy;

my $cfg_file = shift || './perlanetrc';

my $cfg = LoadFile($cfg_file);

my @entries;

foreach my $f (@{$cfg->{feeds}}) {
  my $feed = eval { XML::Feed->parse(URI->new($f->{url})) };

  if ($@) {
    warn "$f->{url}\n$@\n";
    next;
  }

  unless ($feed) {
    warn "$f->{url}\nNo feed\n";
    next;
  }

  $feed = $feed->convert($cfg->{feed}{format});

  unless (defined $f->{title}) {
    $f->{title} = $feed->title;
  }

  push @entries, map { $_->title($f->{title} . ': ' . $_->title); $_ }
                       $feed->entries;
}

my $entries = max(scalar @entries, $cfg->{entries});

my $day_zero = DateTime->from_epoch(epoch=>0);

@entries = sort {
                  ($b->issued || $b->modified || $day_zero)
                   <=>
                  ($a->issued || $b->modified || $day_zero)
                } @entries;

my %tidy = (
  doctype      => 'omit',
  output_xhtml => 1,
  wrap         => 0,
  alt_text     => '',
  break_before_br => 0,
  input_encoding => 'utf8',
  output_encoding => 'utf8',
  tidy_mark => 0,
  show_body_only => 1,
);

my $tidy = HTML::Tidy->new(\%tidy);
$tidy->ignore( type => TIDY_WARNING );

my $f = XML::Feed->new($cfg->{feed}{format});
$f->title($cfg->{title});
$f->link($cfg->{url});
$f->description($cfg->{description});
$f->author($cfg->{author});
$f->modified(DateTime->now);
foreach (1 .. $entries) {
  my $entry = $entries[$_ - 1];

  if ($entry->content->type eq 'text/html') {
    my $clean = $tidy->clean($entry->content->body);
    $entry->content($clean);
  }

  $f->add_entry($entry);
}

open my $feedfile, '>', $cfg->{feed}{file} or die $!;
print $feedfile $f->as_xml;
close $feedfile;

my $tt = Template->new;

$tt->process($cfg->{page}{template},
             { feed => $f },
             $cfg->{page}{file})
  or die $tt->error;
