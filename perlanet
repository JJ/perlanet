#!/usr/bin/perl

use strict;
use warnings;

use List::Util 'min';
use URI;
use XML::Feed;
use Template;
use DateTime;
use DateTime::Duration;
use YAML 'LoadFile';
use HTML::Tidy;
use HTML::Scrubber;

my $cfg_file = shift || './perlanetrc';

my $cfg = LoadFile($cfg_file);

my @entries;

foreach my $f (@{$cfg->{feeds}}) {
  my $feed = eval { XML::Feed->parse(URI->new($f->{url})) };

  if ($@) {
    warn "$f->{url}\n$@\n";
    next;
  }

  unless ($feed) {
    warn "$f->{url}\nNo feed\n";
    next;
  }

  $feed = $feed->convert($cfg->{feed}{format});

  unless (defined $f->{title}) {
    $f->{title} = $feed->title;
  }

  push @entries, map { $_->title($f->{title} . ': ' . $_->title); $_ }
                       $feed->entries;
}

my $entries = min(scalar @entries, $cfg->{entries});

my $day_zero = DateTime->from_epoch(epoch=>0);

@entries = sort {
                  ($b->issued || $b->modified || $day_zero)
                   <=>
                  ($a->issued || $b->modified || $day_zero)
                } @entries;

my $week_in_future = DateTime->now + DateTime::Duration->new(weeks => 1);
@entries =
  grep { ($_->issued || $_->modified || $day_zero) < $week_in_future }
  @entries;

my %tidy = (
  doctype      => 'omit',
  output_xhtml => 1,
  wrap         => 0,
  alt_text     => '',
  break_before_br => 0,
  input_encoding => 'utf8',
  output_encoding => 'utf8',
  tidy_mark => 0,
  show_body_only => 1,
);

my %scrub_rules = (
  img => {
    src   => qr{^http://},    # only URL with http://
    alt   => 1,               # alt attributes allowed
    align => 1,               # allow align on images
    style => 1,
    '*'   => 0,               # deny all others
  },
  style  => 0,
  script => 0,
);

my %scrub_def = (
  '*'           => 1,
  'href'        => qr{^(?!(?:java)?script)}i,
  'src'         => qr{^(?!(?:java)?script)}i,
  'cite'        => '(?i-xsm:^(?!(?:java)?script))',
  'language'    => 0,
  'name'        => 1,
  'value'       => 1,
  'onblur'      => 0,
  'onchange'    => 0,
  'onclick'     => 0,
  'ondblclick'  => 0,
  'onerror'     => 0,
  'onfocus'     => 0,
  'onkeydown'   => 0,
  'onkeypress'  => 0,
  'onkeyup'     => 0,
  'onload'      => 0,
  'onmousedown' => 0,
  'onmousemove' => 0,
  'onmouseout'  => 0,
  'onmouseover' => 0,
  'onmouseup'   => 0,
  'onreset'     => 0,
  'onselect'    => 0,
  'onsubmit'    => 0,
  'onunload'    => 0,
  'src'         => 1,
  'type'        => 1,
  'style'       => 1,
);

my $tidy = HTML::Tidy->new(\%tidy);
$tidy->ignore( type => TIDY_WARNING );

my $scrub = HTML::Scrubber->new;
$scrub->rules(%scrub_rules);
$scrub->default(1, \%scrub_def);

my $f = XML::Feed->new($cfg->{feed}{format});
$f->title($cfg->{title});
$f->link($cfg->{url});
$f->description($cfg->{description});
$f->author($cfg->{author});
$f->modified(DateTime->now);
foreach (1 .. $entries) {
  my $entry = $entries[$_ - 1];

  if ($entry->content->type && $entry->content->type eq 'text/html') {
    my $clean = $tidy->clean($entry->content->body);
    my $scrubbed = $scrub->scrub($clean);
    $entry->content($scrubbed);
  }

  $f->add_entry($entry);
}

open my $feedfile, '>', $cfg->{feed}{file} or die $!;
print $feedfile $f->as_xml;
close $feedfile;

my $tt = Template->new;

$tt->process($cfg->{page}{template},
             { feed => $f },
             $cfg->{page}{file},
             { binmode => ':utf8' })
  or die $tt->error;
